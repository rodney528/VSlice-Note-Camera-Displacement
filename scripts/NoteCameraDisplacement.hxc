import funkin.modding.module.Module;

import funkin.play.notes.SustainTrail;
import funkin.play.PlayState;
import funkin.util.Constants;

import flixel.util.FlxTimer;
import flixel.math.FlxMath;

class NoteCameraDisplacement extends Module {
	/**
	 * Enable the displacement.
	 */
	var enableDisplacement:Bool = true;

	/**
	 * The amount of displacement the notes can create.
	 */
	var displacement:Float = 30;
	/**
	 * Change camera speed when hitting notes (reverts when none are being hit).
	 */
	var velocity:Float = 1.5;
	/**
	 * With this on the camera will slowly lose its displacement instead of just moving back at the end of a note.
	 */
	var sustainDisplacement:Bool = true;

	/**
	 * Due to the script setting `camGame.followLerp` this var kinda needs to exist if you want to edit followLerp at all.
	 */
	var cameraSpeed:Float = 1;

	public function new() {
		super('Note Camera Displacement');
	}

	function getDisplacementValue(direction:Int):Array<Float> {
		var amount:Float = displacement / PlayState.instance.camGame.zoom;
		return switch (direction) {
			case 0: [-amount, 0];
			case 1: [0, amount];
			case 2: [0, -amount];
			case 3: [amount, 0];
		}
	}

	/**
	simple example for setting the vars in other scripts
	```haxe
	import funkin.modding.module.ModuleHandler;
	// does setting this actually work?
	var camNoteMove = ModuleHandler.getModule('Note Camera Displacement');
	override public function onSongStart(event):Void {
		super.onSongStart(event);
		camNoteMove.displacement = 50;
	}
	override public function onSongEnd(event):Void {
		super.onSongEnd(event);
		camNoteMove.displacement = 30;
	}
	```
	**/

	public var camTarget:String = 'none';
	override public function onSongEvent(event):Void {
		super.onSongEvent(event);
		if (event.eventData.eventKind == 'FocusCamera') {
			var prevTarget:String = camTarget;
			switch (Std.parseInt(event.eventData.value.char)) {
				case -1: camTarget = 'none';
				case 0: camTarget = 'player';
				case 1: camTarget = 'opponent';
				case 2: camTarget = 'spectator';
			}
			if (camTarget != prevTarget) {
				if (resetTimer.active) resetTimer.cancel();
				PlayState.instance.camGame.followLerp = Constants.DEFAULT_CAMERA_FOLLOW_RATE * cameraSpeed;
				PlayState.instance.camGame.targetOffset.set();
			}
		}
	}

	var encounteredHolds = {
		opponent: [],
		player: []
	}
	function addHold(hold:SustainTrail, isPlayer:Bool):Void {
		if (isPlayer) {
			if (!encounteredHolds.player.contains(hold))
				encounteredHolds.player.push(hold);
		} else {
			if (!encounteredHolds.opponent.contains(hold))
				encounteredHolds.opponent.push(hold);
		}
	}
	function removeHold(hold:SustainTrail):Void {
		if (encounteredHolds.opponent.contains(hold))
			encounteredHolds.opponent.push(hold);
		if (encounteredHolds.player.contains(hold))
			encounteredHolds.player.push(hold);
	}
	function getHolds(?isPlayer:Bool):Array<SustainTrail> {
		return switch (isPlayer) {
			case false: encounteredHolds.opponent;
			case true: encounteredHolds.player;
			case null: [
				for (array in [encounteredHolds.opponent, encounteredHolds.player])
					for (hold in array)
						hold
			];
		}
	}

	var ranCode:Bool = false;
	override public function onUpdate(event):Void {
		super.onUpdate(event);
		if (PlayState.instance != null && ranCode && enableDisplacement && sustainDisplacement) {
			for (hold in getHolds(switch (camTarget) {
				case 'opponent': false;
				case 'player': true;
				default: null;
			})) {
				if (hold == null || !hold.alive) continue;
				if (hold.hitNote && !hold.missedNote && hold.sustainLength > 0) {
					var percentMath:Float = 1;
					percentMath = FlxMath.bound(FlxMath.remapToRange(hold.sustainLength, 0, hold.fullSustainLength, 0, 1), 0, 1);
					var value:Array<Float> = getDisplacementValue(hold.noteDirection);
					PlayState.instance.camGame.targetOffset.set(value[0] * percentMath, value[1] * percentMath);
					// trace('Hold Note: ' + percentMath);
				}
			}
		}
	}

	var resetTimer:FlxTimer = new FlxTimer();
	override public function onPause(event):Void {
		super.onPause(event);
		resetTimer.active = false;
	}
	override public function onResume(event):Void {
		super.onResume(event);
		resetTimer.active = true;
	}

	override public function onNoteHit(event):Void {
		super.onNoteHit(event);

		if (PlayState.instance != null) {
			var runCode:Bool = ranCode = if (event.note.noteData.getMustHitNote() && camTarget == 'player') true;
			else if (!event.note.noteData.getMustHitNote() && camTarget == 'opponent') true;
			else if (camTarget == 'none') true;
			else false;

			addHold(event.note.holdNoteSprite, event.note.noteData.getMustHitNote());
			if (!runCode) return;

			if (enableDisplacement) {
				PlayState.instance.camGame.targetOffset.set();
				var value:Array<Float> = getDisplacementValue(event.note.direction);
				PlayState.instance.camGame.targetOffset.set(value[0], value[1]);
			}
			PlayState.instance.camGame.followLerp = (Constants.DEFAULT_CAMERA_FOLLOW_RATE * cameraSpeed * velocity) / PlayState.instance.camGame.zoom;

			if (resetTimer.active) resetTimer.cancel();
			var timeLength:Float = event.note.length > 0 ? PlayState.instance.conductorInUse.stepLengthMs * 1.6 + event.note.length : PlayState.instance.conductorInUse.stepLengthMs * 1.6;
			resetTimer.start(timeLength / 1000, (_) -> {
				ranCode = false;
				if (enableDisplacement)
					PlayState.instance.camGame.targetOffset.set();
				PlayState.instance.camGame.followLerp = Constants.DEFAULT_CAMERA_FOLLOW_RATE * cameraSpeed;
			});
		}
	}

	override public function onNoteMiss(event):Void {
		super.onNoteMiss(event);
		generalNoteMiss(event, false);
	}
	override public function onNoteHoldDrop(event):Void {
		super.onNoteHoldDrop(event);
		generalNoteMiss(event, true);
	}

	function generalNoteMiss(event, isHold:Bool):Void {
		if (camTarget == 'player') {
			ranCode = false;
			removeHold(event.holdNote);
			if (resetTimer.active) resetTimer.cancel();
			PlayState.instance.camGame.targetOffset.set();
			PlayState.instance.resetCamera();
		}
	}
}